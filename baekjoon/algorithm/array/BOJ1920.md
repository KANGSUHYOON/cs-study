# BOJ 1920 - 수 찾기
## 📖문제 요약
정수 N개가 들어있는 배열 **A**가 주어질 때,<br>
M개의 정수 x에 대해 **x가 존재하는지** 출력한다.
- 존재하면 `1`
- 없으면 `0`

## ⛔내가 생각한 접근법 (시간 초과)
`M`개의 값마다 `A`를 처음부터 끝까지 `find`(선형 탐색)하면:
- `find 1번` : O(N)
- `M번 반복` : O(N×M)
N, M이 최대 100,000이라 최악의 경우 10¹⁰ → 시간초과

## 💡해결 법
배열 A를 **한 번 정렬**해두면, <br>
**이진 탐색(bianry search)** 으로 빠르게 찾을 수 있다.

## ⚙️알고리즘 회로도
1. N 입력
2. 배열 A 입력
3. `A 정렬`
4. M 입력
5. M번 반복:
    - x 입력
    - `bianry_search(A, A+N, x)`
        - 있으면 1 출력
        - 없으면 0 출력

## ⏰시간복잡도
- 정렬(sort): `O(N log N)`
- 질의 M개: `M × O(log N)`
- 총합: **`O(N log N + M log N)`**

## ⌨️CODE
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    int* A = new int[N];
    for (int i = 0; i < N; i++) cin >> A[i];

    sort(A, A + N);

    int M;
    cin >> M;

    for (int i = 0; i < M; i++) {
        int x;
        cin >> x;

        if (binary_search(A, A + N, x)) cout << 1 << '\n';
        else cout << 0 << '\n';
    }

    delete[] A;
    return 0;
}

```
[포인터의 기본 개념 정리](cs-study/cpp/basic/deepeningPointer.md)
