# 🗃️백준 9020 골드바흐의 추측 GitHub 정리

## 📖문제 요약
짝수 N이 주어졌을 때, <br>
N = a + b 를 만족하는 두 소수 a, b를 찾는다.

단, <br>

- a와 b는 모두 소수
- 두 수의 차이가 가장 작은 조합을 출력해야 한다.

## 💡아이디어

### 1) 가운데에서 시작하면 차이가 최소
차이가 가장 작으려면 두 수가 가장 가까워야 하므로 <br>
**a = b N / 2**
에서 시작해 범위를 넓혀가며 탐색한다. <br>
예를 들어 N = 28이면 <br>

- 14 + 14 (소수X)
- 13 + 15
- 12 + 16
- ...
- 11 + 17

즉,<br>
- a는 감소
- b는 증가
방식으로 찾으면 된다.

### 2) 소수 판별은 ✓N까지만 검사하면 된다
- 소수 판별식은 그냥 구글 검색해서 찾았다. <br>
**2 ~  ✓x 까지만 나누어 떨어지는지 확인**하면 충분하다.
```cpp
bool isPrime(int x) {
  if (x < 2) return false;
  for (int i = 2; i * i <= x; i++) {
    if (x % i == 0) return false;
  }
  return true;
}
```

## ⌨️전체 코드
```cpp
#include <iostream>
using namespace std;

bool isPrime(int x) {
  if (x < 2) return false;
  for (int i = 2; i * i <= x; i++) {
    if (x % i == 0) return false;
  }
  return true;
}
int main() {
    int T;
    cin >> T;

    while (T--) {
        int N;
        cin >> N;

        int a = N / 2;
        int b = N / 2;

        while (true) {
            if (isPrime(a) && isPrime(b)) {
                cout << a << " " << b << "\n";
                break;
            }
            a--;
            b++;
        }
    }
    return 0;
}
```

## 🔖배운 점
✔️ 제출 전에 항상 디버그를 해보자.<br>
✔️ 골드바흐 파티션은 **중앙(N/2)에서 시작하는 탐색**이 가장 효율적이다.<br>
✔️ 소수판별은 ✓N까지만 검사하면 된다.
