# BOJ 1654 - ✂️랜선 자르기

## 🔍문제 요약
K개의 랜선을 동일한 길이로 잘라 **N개 이상**의 랜선을 만들려고 한다.<br>
이때 만들 수 있는 랜선 길이의 **최댓값**을 구하는 문제이다.

## 💡핵심 아이디어
이 문제는 **정답을 이진 탐색하는 문제**이다.
- 우리가 정하는 값은 **자르는 길이** `x`
- `x`가 커질수록 만들 수 있는 랜선 개수는 **단조 감소**(일정하게)
- 따라서 어떤 `x`가 가능하면 그보다 작은 값은 모두 가능하고, <br>
  불가능하면 그보다 큰 값은 모두 불가능하다.
👉 이러한 **가능 / 불가능의 경계**를 이진 탐색으로 찾는다.

## 🧠나의 깨닳음
- 이 문제는 <br>
  정확히 N개가 나오게 하는 길이를 찾는 문제가 아니라<br>
  **N개 이상 만들 수 있는 길이 중 최댓값**을 찾는 문제이다.
- 예제에서 계산으로 나온 231은 <br>
  -> 실제로는 N개를 만들지 못하므로 **불가능한 값**이었다.

## ⚙️판정 함수 설계
자르는 길이 `x`가 주어졌을 때,<br>
몇 개의 랜선이 만들어지는지 계산하는 함수를 분리한다.
```cpp
long long pieces(const vector<long long>& A, long long x) {
    long long cnt = 0;
    for (long long len : A) {
        cnt += len / x;
    }
    return cnt;
}
```
- `len`은 vector 안에 들어 있는 **각 랜선의 길이**
- `A[i] / x`의 합이 만들 수 있는 총 랜선 개수

## 🤖이진 탐색 로직
1. 탐색 범위 설정
  - `lo = 1` 
  - `hi = 가장 긴 랜선 길이`
2. 중간값 `mid`로 잘랐을 때
  - `pieces(mid) >= N` -> 가능 -> 더 긴 길이 탐색
  - `pieces(mid) < N` -> 불가능 -> 길이를 줄임
3. 가능한 값 중 **최댓값**을 저장

## ⌨️CODE
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

long long pieces(const vector<long long>& A, long long x) {
    long long cnt = 0;
    for (long long len : A) {
        cnt += len / x;
    }
    return cnt;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int K, N;
    cin >> K >> N;

    vector<long long> A(K);
    long long hi = 0;

    for (int i = 0; i < K; i++) {
        cin >> A[i];
        hi = max(hi, A[i]);
    }

    long long lo = 1;  // 1부터 가장 큰 값 사이 어딘가에 있음
    long long ans = 0;

    while (lo <= hi) {
        long long mid = (lo + hi) / 2;

        if (pieces(A, mid) >= N) {
            ans = mid;        // 가능한 길이 저장
            lo = mid + 1;     // 더 긴 길이 탐색
        } else {
            hi = mid - 1;     // 길이 줄이기
        }
    }

    cout << ans << '\n';
    return 0;
}
```

## ⚠️주의할 점
- `lo = 0` ✖️ -> 0으로 나누기 발생
- 개수 합은 커질 수 있으므로 `long long` 사용
- `>= N`일 때 **오른쪽 탐색** (최댓값 문제)

## 📝느낀 점
- 단순 계산으로 접근하면 안된다
- "조건을 만족하는가?"라는 **판정 문제**로 바꾸는 사고가 중요했다
- 이진 탐색은 배열이 아니라 **정답 공간**에서도 사용될 수 있다
