# BOJ 2805 - 나무 자르기

## 1. 문제 요약
N개의 나무 높이가 주어질 때, 톱날 높이를 설정하여 <br>
**적어도 M미터의 나무를 얻을 수 있는 최대 절단 높이**를 구하는 문제 

## 2.핵심 개념
✔️이 문제는 **배열 이진 탐색이 아니라 정답 공간 이진 탐색**이다.
- 탐색 대상: "자르는 높이(cutHeight)"
- 범위: `0 ~ maxHeight`
- 조건 함수:
  ```
  wood(cutHeight) = Σ max(0, treeHeight - cutHeight)
  ```
📌cutHeight가 커질수록 wood는 감소한다. <br>
-> 단조 감소 함수<br>
-> 이진 탐색 가능

## 3. 탐색 전략
- `wood >- M`
  -> 더 높게 잘라도 될 수 있음
  -> `low = mid + 1`
  -> 현재 mid 저장
- `wood < M`
  -> 너무 높게 잘랐다
  -> `high = mid - 1`

➡️목표는 **조건을 만족하는 최대 cutHeight**


## 4. 시간 복잡도
- O(N log H)
  - H = 최대 나무 높이



## 5. 실수 포인트
- ❗`wood`는 반드시 `long long`
- ❗정렬은 필요 없음
- ❗조건이 `>=` 인지 `>`인지 헷갈리기 쉬움


## 6. 내가 느낀 중요 포인트
- BOJ 1654와 구조가 거의 동일했다
- 배열을 탐색하는 게 아니라 "답이 될 수 있는 값"을 탐색한다는 개념이 중요하다
- 혼자 처음 보면 절대 직관적으로 안 떠오르는 유형



## ⌨️완성 코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int treeCount;
    long long requiredWood;
    cin >> treeCount >> requiredWood;

    vector<int> treeHeights(treeCount);
    int maxHeight = 0;

    for (int i = 0; i < treeCount; i++) {
        cin >> treeHeights[i];
        if (treeHeights[i] > maxHeight) maxHeight = treeHeights[i];
    }

    int lowCutHeight = 0;
    int highCutHeight = maxHeight;

    int bestCutHeight = 0;

    while (lowCutHeight <= highCutHeight) {
        int cutHeight = lowCutHeight + (highCutHeight - lowCutHeight) / 2;

        long long collectedWood = 0;  // 잘라서 가져가는 목재 총합
        for (int h : treeHeights) {
            if (h > cutHeight) {
                collectedWood += (h - cutHeight);
            }
        }

        if (collectedWood >= requiredWood) {
            // 충분히 가져갈 수 있으니, 더 높게 잘라도 되는지(최댓값) 시도
            bestCutHeight = cutHeight;
            lowCutHeight = cutHeight + 1;
        } else {
            // 부족하니 너무 높게 잘랐다 -> cutHeight를 낮춰야 함
            highCutHeight = cutHeight - 1;
        }
    }

    cout << bestCutHeight << '\n';
    return 0;
}
```
